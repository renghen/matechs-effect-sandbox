{"version":3,"sources":["utils/tuple.ts","utils/getter.ts","utils/effect.ts","modules/canvas/index.ts","modules/emitter/index.ts","utils/string.ts","apps/circles/index.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["tuple","ts","getter","key","o","getter2","k1","k2","dot","fromIO","io","T","sync","rndColor","alpha","Do","effect","bind","Rnd","pure","pipe","IO","a","return","r","g","b","takeUntil","until","s","stream","wrappedUntil","S","as","type","encaseEffect","wrappedStream","map","value","mergeAll","takeWhile","wrapped","filter","takeUntil_","uri","clear","accessM","_","clearRect","accessCanvas","canvas","canvasPropIfNot","prop","el","accessCanvasProp","canvasWidthIfNot","canvasHeightIfNot","makeClearRectLive","ctx","x","y","width","height","doL","args","parseInstruction","instruction","arc","beginPath","fill","fillStyle","lineWidth","stroke","strokeStyle","subscribe","fromSource","M","managed","chain","bracket","su","queueUtils","next","ops","hasCB","unsubscribe","addEventListener","fromEvent","fn","_tag","emitter","charCodeAt","at","str","mapMouseEventToCoords","e","offsetX","offsetY","makeOnClick","makeEffect","Canvas","canvasEl","Emitter","flow","drawCirclesOnClick","sa","ea","zip","Math","PI","list","A","sequence","drawMarkerOnClick","makeWaitForMenuChoice","menuCodes","includes","take","collectArray","String","fromCharCode","waitForMainMenuChoice","waitForToolMenuChoice","makeDoUntilMenuChoice","parZip","identity","instructions","main","ref","makeRef","stateRef","forever","do","get","state","bindL","mainMenuChoice","update","additionalInstructions","current","concat","done","useCircles","canvasRef","React","getContext","provideS","rootEl","document","cb","removeEventListener","radius","startAngle","endAngle","anticlockwise","abs","color","provideConsole","run","useCanvas","useRef","useState","setSize","useEffect","setTimeout","parentElement","console","log","getBoundingClientRect","App","Circles","id","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.ed15e86a.chunk.js","sourcesContent":["export const tuple = <T extends any[]>(...ts: T) => ts;","/**\r\n * @packageDocumentation\r\n * @module utils\r\n */\r\n\r\n/**\r\n * Type that describes a function that returns\r\n * the value of on object's property given\r\n *\r\n * @typeparam TKey The key or property name the function should read and return from a given object.\r\n * @typeparam TValue The value type\r\n * @typeparam TObject The object type\r\n */\r\nexport type Getter<TKey extends string> = <\r\n  TValue,\r\n  TObject extends {\r\n    [P in TKey]: TValue;\r\n  }\r\n>(\r\n  o: TObject\r\n) => TObject[TKey];\r\n\r\n/**\r\n *\r\n * @param key\r\n */\r\nexport const getter = <K extends string>(key: K): Getter<K> => <\r\n  T,\r\n  O extends { [P in K]: T }\r\n>(\r\n  o: O\r\n) => o[key];\r\n\r\nexport const getter2 = <K1 extends string, K2 extends string>(\r\n  k1: K1,\r\n  k2: K2\r\n) => <T, O extends { [P in K1]: { [R in K2]: T } }>(o: O) => o[k1][k2];\r\n\r\nexport const dot = getter;\r\nexport const dot2 = getter2;\r\nexport const pluck = getter;\r\nexport const pluck2 = getter2;\r\n\r\nexport const getEventCurrentTargetValue = dot2(\"detail\", \"value\");\r\n","import * as IO from \"fp-ts/lib/IO\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { effect as T, stream as S } from \"@matechs/effect\";\r\n\r\nexport const fromIO = <T>(io: IO.IO<T>) => {\r\n  return T.sync(() => io());\r\n};\r\n\r\nexport const rndColor = (alpha?: number) =>\r\n  Do(T.effect)\r\n    .bind(\"r\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\"g\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\"b\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\r\n      \"a\",\r\n      alpha != null\r\n        ? T.pure(alpha)\r\n        : fromIO(\r\n            pipe(\r\n              Rnd.randomInt(0, 10),\r\n              IO.map((a) => a / 10)\r\n            )\r\n          )\r\n    )\r\n    .return(({ r, g, b, a }) => `rgba(${r}, ${g}, ${b}, ${a})`);\r\n\r\n/**\r\n * Take elements from a stream until a given effect resolves.\r\n *\r\n * @param until The effect that will terminate the stream\r\n * @param stream The stream\r\n */\r\nfunction takeUntil_<R1, E1, R2, E2, A>(\r\n  stream: S.Stream<R1, E1, A>,\r\n  until: T.Effect<R2, E2, any>\r\n) {\r\n  type Wrapped = { type: \"until\" } | { type: \"stream\"; value: A };\r\n\r\n  const wrappedUntil = S.as<Wrapped>({ type: \"until\" })(S.encaseEffect(until));\r\n\r\n  const wrappedStream = pipe(\r\n    stream,\r\n    S.map((value): Wrapped => ({ type: \"stream\", value }))\r\n  );\r\n\r\n  return pipe(\r\n    S.mergeAll([wrappedUntil as any, wrappedStream as any] as S.Stream<\r\n      R1 & R2,\r\n      E1 | E2,\r\n      Wrapped\r\n    >[]),\r\n    S.takeWhile((wrapped) => wrapped.type === \"stream\"),\r\n    S.filter(\r\n      (wrapped): wrapped is Extract<Wrapped, { type: \"stream\" }> =>\r\n        wrapped.type === \"stream\"\r\n    ),\r\n    S.map((wrapped) => (wrapped as Extract<Wrapped, { type: \"stream\" }>).value)\r\n  );\r\n}\r\n\r\nexport function takeUntil<R2, E2>(until: T.Effect<R2, E2, any>) {\r\n  return function <R1, E1, A>(s: S.Stream<R1, E1, A>) {\r\n    return takeUntil_(s, until);\r\n  };\r\n}\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport * as A from \"fp-ts/lib/Array\";\r\n\r\nimport { fromIO, rndColor } from \"../../utils/effect\";\r\nimport { tuple } from \"../../utils/tuple\";\r\n\r\nexport const uri = \"@uri/canvas\";\r\n\r\ninterface Flavoring<FlavorT> {\r\n  _type?: FlavorT;\r\n}\r\n\r\nexport type Flavor<T, FlavorT> = T & Flavoring<FlavorT>;\r\n\r\ntype Radian = Flavor<number, \"radius\">;\r\n\r\ntype Arc = {\r\n  type: \"@instruction/arc\";\r\n  args: [number, number, number, number, number, boolean];\r\n};\r\n\r\ntype ClearRect = {\r\n  type: \"@instruction/clearRect\";\r\n  args: [number, number, number, number];\r\n};\r\n\r\ntype BeginPath = { type: \"@instruction/beginPath\" };\r\ntype Stroke = { type: \"@instruction/stroke\" };\r\ntype Fill = { type: \"@instruction/fill\" };\r\ntype LineWidth = { type: \"@instruction/lineWidth\"; args: [number] };\r\ntype StrokeStyle = { type: \"@instruction/strokeStyle\"; args: [string] };\r\ntype FillStyle = { type: \"@instruction/fillStyle\"; args: [string] };\r\n\r\nexport type Instruction =\r\n  | Arc\r\n  | ClearRect\r\n  | BeginPath\r\n  | Stroke\r\n  | Fill\r\n  | LineWidth\r\n  | StrokeStyle\r\n  | FillStyle;\r\n\r\nexport type Tagged<T> = { type: \"@tag\"; instructions: Instruction[]; data: T };\r\n\r\nexport const tag = (instructions: Instruction[]) => <T>(\r\n  data: T\r\n): Tagged<T> => ({ type: \"@tag\", instructions, data });\r\n\r\nexport interface Canvas {\r\n  [uri]: {\r\n    canvas: T.UIO<HTMLCanvasElement>;\r\n    clearRect: (\r\n      x?: number,\r\n      y?: number,\r\n      width?: number,\r\n      height?: number\r\n    ) => T.RUIO<Canvas, Instruction>;\r\n    arc: (\r\n      x: number,\r\n      y: number,\r\n      radius: number,\r\n      startAngle: Radian,\r\n      endAngle: Radian,\r\n      anticlockwise?: boolean | undefined\r\n    ) => T.UIO<Instruction>;\r\n    lineWidth: (width: number) => T.UIO<Instruction>;\r\n    beginPath: T.UIO<Instruction>;\r\n    stroke: T.UIO<Instruction>;\r\n    fill: T.UIO<Instruction>;\r\n    strokeStyle: (color: string) => T.UIO<Instruction>;\r\n    fillStyle: (color: string) => T.UIO<Instruction>;\r\n  };\r\n}\r\n\r\n/**\r\n * circle :: number -> number -> number -> number? -> number? -> Effect Canvas never (number, number, number)\r\n *\r\n * Draws a circle on the canvas. X, y, and radius are returned again.\r\n */\r\nexport const circle = (\r\n  x: number,\r\n  y: number,\r\n  r: number,\r\n  sa?: number,\r\n  ea?: number\r\n) =>\r\n  T.accessM((_: Canvas) => {\r\n    const ctx = _[uri];\r\n    return pipe(\r\n      T.zip(\r\n        sa ? T.pure(sa) : fromIO(Rnd.randomInt(0, 360)),\r\n        ea\r\n          ? T.pure(ea)\r\n          : fromIO(Rnd.randomInt((Math.PI / 10) * 1000, Math.PI * 1000))\r\n      ),\r\n      T.chain(([sa, ea]) => {\r\n        const list: T.UIO<Instruction>[] = [\r\n          pipe(rndColor(1), T.chain(ctx.strokeStyle)),\r\n          pipe(rndColor(), T.chain(ctx.fillStyle)),\r\n          ctx.lineWidth(2),\r\n          ctx.beginPath,\r\n          ctx.arc(x, y, r, sa, ea / 1000),\r\n          ctx.stroke,\r\n          ctx.fill,\r\n        ];\r\n\r\n        return A.array.sequence(T.effect)(list);\r\n      })\r\n    );\r\n  });\r\n\r\n/**\r\n * clear :: T.Effect Canvas never void\r\n *\r\n * Clears a canvas\r\n */\r\nexport const clear = T.accessM((_: Canvas) => _[uri].clearRect());\r\n\r\nconst accessCanvas = T.accessM((_: Canvas) => _[uri].canvas);\r\n\r\nconst accessCanvasProp = <TProp extends keyof HTMLCanvasElement>(prop: TProp) =>\r\n  pipe(\r\n    accessCanvas,\r\n    T.map((el) => el[prop])\r\n  );\r\n\r\nconst canvasPropIfNot = <TProp extends keyof HTMLCanvasElement>(\r\n  prop: TProp\r\n) => (value?: HTMLCanvasElement[TProp]) =>\r\n  value != null ? T.pure(value) : accessCanvasProp(prop);\r\n\r\nconst canvasWidthIfNot = canvasPropIfNot(\"width\");\r\nconst canvasHeightIfNot = canvasPropIfNot(\"height\");\r\n\r\nconst makeClearRectLive = (ctx: CanvasRenderingContext2D) => (\r\n  x?: number,\r\n  y?: number,\r\n  width?: number,\r\n  height?: number\r\n): T.Effect<Canvas, never, ClearRect> =>\r\n  Do(T.effect)\r\n    .bind(\"width\", canvasWidthIfNot(width))\r\n    .bind(\"height\", canvasHeightIfNot(height))\r\n    .doL(({ width, height }) =>\r\n      T.sync(() => ctx.clearRect(x || 0, y || 0, width, height))\r\n    )\r\n    .return(({ width, height }) => ({\r\n      type: \"@instruction/clearRect\",\r\n      args: tuple(x || 0, y || 0, width, height),\r\n    }));\r\n\r\nexport const isInstruction = <TInstructionType extends Instruction[\"type\"]>(\r\n  type: TInstructionType\r\n) => (\r\n  instruction: Instruction\r\n): instruction is Extract<Instruction, { type: TInstructionType }> =>\r\n  instruction.type === type;\r\n\r\nexport const parseInstruction = (instruction: Instruction) =>\r\n  T.accessM((_: Canvas): T.Effect<Canvas, never, Instruction> => {\r\n    const ctx = _[uri];\r\n\r\n    switch (instruction.type) {\r\n      case \"@instruction/arc\": {\r\n        return ctx.arc(...instruction.args);\r\n      }\r\n      case \"@instruction/beginPath\": {\r\n        return ctx.beginPath;\r\n      }\r\n      case \"@instruction/clearRect\": {\r\n        return ctx.clearRect(...instruction.args);\r\n      }\r\n      case \"@instruction/fill\": {\r\n        return ctx.fill\r\n      }\r\n      case \"@instruction/fillStyle\": {\r\n        return ctx.fillStyle(...instruction.args);\r\n      }\r\n      case \"@instruction/lineWidth\": {\r\n        return ctx.lineWidth(...instruction.args);\r\n      }\r\n      case \"@instruction/stroke\": {\r\n        return ctx.stroke;\r\n      }\r\n      case \"@instruction/strokeStyle\": {\r\n        return ctx.strokeStyle(...instruction.args);\r\n      }\r\n    }\r\n  });\r\n\r\nexport const parseInstructions = (instructions: Instruction[]) => pipe(\r\n    instructions,\r\n    A.map(parseInstruction),\r\n    A.array.sequence(T.effect)\r\n)\r\n\r\nexport const makeCanvasLive = (ctx: CanvasRenderingContext2D): Canvas => {\r\n  return {\r\n    [uri]: {\r\n      canvas: T.pure(ctx.canvas),\r\n      arc: (\r\n        x: number,\r\n        y: number,\r\n        radius: number,\r\n        startAngle: Radian,\r\n        endAngle: Radian,\r\n        anticlockwise = false\r\n      ) =>\r\n        T.as(\r\n          T.sync(() =>\r\n            ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)\r\n          ),\r\n          {\r\n            type: \"@instruction/arc\",\r\n            args: [x, y, radius, startAngle, endAngle, anticlockwise],\r\n          }\r\n        ),\r\n      clearRect: makeClearRectLive(ctx),\r\n      beginPath: T.as(\r\n        T.sync(() => ctx.beginPath()),\r\n        { type: \"@instruction/beginPath\" }\r\n      ),\r\n      stroke: T.as(\r\n        T.sync(() => ctx.stroke()),\r\n        { type: \"@instruction/stroke\" }\r\n      ),\r\n      fill: T.as(\r\n        T.sync(() => ctx.fill()),\r\n        { type: \"@instruction/fill\" }\r\n      ),\r\n      lineWidth: (width: number) =>\r\n        T.as(\r\n          T.sync(() => {\r\n            ctx.lineWidth = Math.abs(width);\r\n          }),\r\n          { type: \"@instruction/lineWidth\", args: [width] }\r\n        ),\r\n      strokeStyle: (color: string) =>\r\n        T.as(\r\n          T.sync(() => {\r\n            ctx.strokeStyle = color;\r\n          }),\r\n          { type: \"@instruction/strokeStyle\", args: [color] }\r\n        ),\r\n      fillStyle: (color: string) =>\r\n        T.as(\r\n          T.sync(() => {\r\n            ctx.fillStyle = color;\r\n          }),\r\n          { type: \"@instruction/fillStyle\", args: [color] }\r\n        ),\r\n    },\r\n  };\r\n};\r\n","import { effect as T, stream as S, managed as M } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { dot } from \"../../utils/getter\";\r\nimport { log } from \"@matechs/console\";\r\n\r\nexport const uri = \"@uri/emitter\";\r\n\r\ntype EventFor<TEventType extends string> = TEventType extends\r\n  | \"keypress\"\r\n  | \"keyup\"\r\n  | \"keydown\"\r\n  ? KeyboardEvent\r\n  : TEventType extends \"click\" | \"dblclick\"\r\n  ? MouseEvent\r\n  : Event;\r\n\r\ntype EventHandler<TEventType extends string> = (\r\n  evt: EventFor<TEventType>\r\n) => void;\r\n\r\nexport interface Emitter {\r\n  [uri]: {\r\n    fromEvent: <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<T.NoEnv, never, void>;\r\n    addEventListener: <THTMLElement extends HTMLElement>(\r\n      el: THTMLElement\r\n    ) => <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<T.NoEnv, never, void>;\r\n  };\r\n}\r\n\r\n// Events\r\nexport const subscribe = <\r\n  TEventType extends string,\r\n  THTMLElement extends HTMLElement\r\n>(\r\n  type: TEventType,\r\n  el?: THTMLElement\r\n) => {\r\n  return S.fromSource(\r\n    M.managed.chain(\r\n      M.bracket(\r\n        T.accessM((_: Emitter) =>\r\n          T.sync(() => {\r\n            const { next, ops, hasCB } = S.su.queueUtils<\r\n              never,\r\n              EventFor<TEventType>\r\n            >();\r\n\r\n            const fn = el ? _[uri].addEventListener(el) : _[uri].fromEvent;\r\n\r\n            return {\r\n              unsubscribe: fn(type)((a) => next({ _tag: \"offer\", a })),\r\n              ops,\r\n              hasCB,\r\n            };\r\n          })\r\n        ),\r\n        dot(\"unsubscribe\")\r\n      ),\r\n      ({ ops, hasCB }) => S.su.emitter(ops, hasCB)\r\n    )\r\n  );\r\n};\r\n\r\nexport const makeEmitterLive = <\r\n  TRoot extends Pick<HTMLElement, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  rootEl: TRoot\r\n): Emitter => {\r\n  return {\r\n    [uri]: {\r\n      fromEvent: <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        rootEl.addEventListener(type, cb as any);\r\n\r\n        return T.sync(() => rootEl.removeEventListener(type, cb as any));\r\n      },\r\n      addEventListener: <THTMLElement extends HTMLElement>(\r\n        el: THTMLElement\r\n      ) => <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        el.addEventListener(type, cb as any);\r\n\r\n        return T.sync(() => el.removeEventListener(type, cb as any));\r\n      },\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * waitForKeyPress :: number -> Effect NoEnv never void\r\n *\r\n * Given a keyCode returns an effect that resolves once the user\r\n * presses a key on the keyboard matching the key code.\r\n */\r\nexport const waitForKeyPress = (...keyCodes: number[]) =>\r\n  T.effect.chain(log(\"Waiting for \", ...keyCodes), () =>\r\n    pipe(\r\n      subscribe(\"keyup\"),\r\n      S.filter((event) => keyCodes.includes(event.keyCode)),\r\n      S.take(1),\r\n      S.collectArray,\r\n      T.map(([evt]) => evt)\r\n    )\r\n  );\r\n","export const charCodeAt = (at: number) => (str: string) => str.charCodeAt(at)","import * as React from \"react\";\r\n\r\nimport { effect as T, stream as S, ref } from \"@matechs/effect\";\r\nimport { provideConsole } from \"@matechs/console\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport * as A from \"fp-ts/lib/Array\";\r\n\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { flow, identity } from \"fp-ts/lib/function\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { dot } from \"../../utils/getter\";\r\n\r\nimport * as Canvas from \"../../modules/canvas\";\r\nimport * as Emitter from \"../../modules/emitter\";\r\nimport { fromIO, takeUntil } from \"../../utils/effect\";\r\nimport { tuple } from \"../../utils/tuple\";\r\nimport { charCodeAt } from \"../../utils/string\";\r\n\r\ntype X = number;\r\ntype Y = number;\r\ntype Radius = number;\r\ntype Angle = number;\r\ntype StartAngle = Angle;\r\ntype EndAngle = Angle;\r\ntype TimeStamp = number;\r\n\r\ntype Circle = [X, Y, Radius, StartAngle, EndAngle];\r\ntype TimeStamped = [X, Y, Radius, StartAngle, EndAngle, TimeStamp];\r\n\r\n/**\r\n * ```hs\r\n * randomCircle :: (number, number) -> Stream Canvas never Circle\r\n * ```\r\n *\r\n * Draws a circle with a random radius\r\n */\r\nconst randomCircle = ([x, y]: [X, Y]) =>\r\n  pipe(\r\n    // Get a random radius for the circle to draw\r\n    Rnd.randomInt(30, 200),\r\n    // Convert IO to Effect\r\n    fromIO,\r\n    // Map effect that produces a random int to an effect that draws a circle\r\n    T.chain((r) => Canvas.circle(x, y, r))\r\n    // Turn the effect into a stream\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * mapMouseEventToCoords :: MouseEvent -> (X, Y\r\n * ```\r\n */\r\nconst mapMouseEventToCoords = (e: MouseEvent) => tuple(e.offsetX, e.offsetY);\r\n\r\nconst makeOnClick = (\r\n  makeEffect: ([x, y]: [X, Y]) => T.Effect<\r\n    Canvas.Canvas,\r\n    never,\r\n    Canvas.Instruction[]\r\n  >\r\n) =>\r\n  pipe(\r\n    // Read canvas element from environment\r\n    T.accessM((_: Canvas.Canvas) => _[Canvas.uri].canvas),\r\n    // Turn it into a stream\r\n    S.encaseEffect,\r\n    // Flat map the 1 element stream containing the canvas element to a stream of mouse clicks\r\n    S.chain((canvasEl) =>\r\n      // encaseObservable(fromEvent<MouseEvent>(canvasEl, \"click\"), constVoid)\r\n      Emitter.subscribe(\"click\", canvasEl)\r\n    ),\r\n    //   // Take mouse clicks until the user presses d or D\r\n    //   takeUntil(Emitter.waitForKeyPress(68)),\r\n    // Map the mouse event to it's coordinates\r\n    S.map(mapMouseEventToCoords),\r\n    // Flat map the stream of coordinates to\r\n    // a stream that draws a circle\r\n    S.chain(flow(makeEffect, S.encaseEffect))\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * drawCirclesOnClick :: Effect (Console & Canvas & Emitter) never [TimeStamped]\r\n * ```\r\n *\r\n * Draw a circle on every mouseclick until the program is terminated by pressing 'd' or 'D'\r\n */\r\nconst drawCirclesOnClick = makeOnClick(randomCircle);\r\n\r\nconst marker = ([x, y]: [number, number]) =>\r\n  T.accessM((_: Canvas.Canvas) => {\r\n    const ctx = _[Canvas.uri];\r\n\r\n    return pipe(\r\n      [\r\n        ctx.beginPath,\r\n        ctx.arc(x, y, 20, 0, Math.PI * 2),\r\n        ctx.strokeStyle(\"#000000\"),\r\n        ctx.fillStyle(\"Yellow\"),\r\n        ctx.lineWidth(2),\r\n        ctx.stroke,\r\n        ctx.fill,\r\n      ],\r\n      A.array.sequence(T.effect)\r\n    );\r\n  });\r\n\r\nconst drawMarkerOnClick = makeOnClick(marker);\r\n\r\nconst makeWaitForMenuChoice = (menuCodes: number[]) =>\r\n  pipe(\r\n    Emitter.subscribe(\"keyup\"),\r\n    S.map(dot(\"keyCode\")),\r\n    S.filter(menuCodes.includes.bind(menuCodes)),\r\n    S.take(1),\r\n    S.collectArray,\r\n    T.map(([keyCode]) => keyCode),\r\n    T.map(String.fromCharCode)\r\n  );\r\n\r\nconst waitForMainMenuChoice = pipe(\r\n  [\"1\", \"2\", \"R\", \"X\"],\r\n  A.map(charCodeAt(0)),\r\n  makeWaitForMenuChoice\r\n);\r\n\r\nconst waitForToolMenuChoice = pipe(\r\n  [\"S\", \"X\"],\r\n  A.map(charCodeAt(0)),\r\n  makeWaitForMenuChoice\r\n);\r\n\r\nconst makeDoUntilMenuChoice = <R, E, A>(\r\n  effect: S.Stream<R, E, Canvas.Instruction[]>\r\n) =>\r\n  pipe(\r\n    // Run 2 effects in parallell\r\n    T.parZip(\r\n      // One that runs the effect until a menu choice (S or X) is pressed\r\n      pipe(\r\n        effect,\r\n        takeUntil(waitForToolMenuChoice),\r\n        S.collectArray,\r\n        T.map(A.chain(identity))\r\n      ),\r\n      // And second the menu choice itself\r\n      waitForToolMenuChoice\r\n    ),\r\n    // If the menu choice was X return an empty list of instructions otherwise return instructions.\r\n    T.map(([instructions, code]) => (code === \"S\" ? instructions : []))\r\n  );\r\n\r\n/**\r\n * Main program\r\n */\r\nconst main = Do(T.effect)\r\n  // Create a ref that stores canvas drawings as serializable instructions.\r\n  .bind(\r\n    \"stateRef\",\r\n    ref.makeRef({\r\n      instructions: [] as Canvas.Instruction[],\r\n    })\r\n  )\r\n  .doL(({ stateRef }) =>\r\n    // Use the ref in a program that runs forever.,\r\n    T.forever(\r\n      Do(T.effect)\r\n        // Clear the canvas on every run.\r\n        .do(Canvas.clear)\r\n        // Convert the instructions in state to effects that draw onto the canvas.\r\n        .do(\r\n          pipe(\r\n            stateRef.get,\r\n            T.chain((state) => Canvas.parseInstructions(state.instructions))\r\n          )\r\n        )\r\n        // Wait for the user to make a choice (1, 2, or X)\r\n        .bind(\"mainMenuChoice\", waitForMainMenuChoice)\r\n        // Allow the user to draw on canvas or clear it if the choice was X\r\n        .bindL(\"additionalInstructions\", ({ mainMenuChoice }) => {\r\n          switch (mainMenuChoice) {\r\n            case \"1\":\r\n              return makeDoUntilMenuChoice(drawCirclesOnClick);\r\n            case \"2\":\r\n              return makeDoUntilMenuChoice(drawMarkerOnClick);\r\n            case \"X\":\r\n              // Empty the instructions in state\r\n              return T.as(\r\n                stateRef.update(() => ({ instructions: [] })),\r\n                []\r\n              );\r\n            default:\r\n              return T.pure([]);\r\n          }\r\n        })\r\n        // Update state and add the new set of instructions to the current set\r\n        .doL(({ additionalInstructions }) =>\r\n          stateRef.update((current) => {\r\n            return {\r\n              instructions: current.instructions.concat(additionalInstructions),\r\n            };\r\n          })\r\n        )\r\n        .done()\r\n    )\r\n  )\r\n  .done();\r\n\r\nexport const useCircles = (\r\n  canvasRef: React.MutableRefObject<HTMLCanvasElement | null>\r\n) =>\r\n  React.useEffect(() => {\r\n    if (canvasRef.current) {\r\n      const ctx = canvasRef.current.getContext(\"2d\");\r\n\r\n      if (ctx) {\r\n        pipe(\r\n          // Run the main program\r\n          main,\r\n          // Provide Emitter which adds support for listening to mouse clicks and keyboard presses\r\n          T.provideS(Emitter.makeEmitterLive(document)),\r\n          // Provide the canvas 2d context\r\n          T.provideS(Canvas.makeCanvasLive(ctx)),\r\n          // Provide console logging capabilities\r\n          provideConsole,\r\n          T.run\r\n        );\r\n      }\r\n    }\r\n  }, [canvasRef]);\r\n","import \"./App.scss\";\n\nimport React from \"react\";\nimport { tuple } from \"./utils/tuple\";\nimport * as Circles from './apps/circles'\n\n// Hooks\nconst useCanvasRef = () => React.useRef<HTMLCanvasElement | null>(null);\nconst useSizeState = () => React.useState(tuple(0, 0));\n\nconst useCanvas = () => {\n  const ref = useCanvasRef()\n  const [[width, height], setSize] = useSizeState()\n\n  React.useEffect(() => {\n    setTimeout(() => {\n      if (ref.current && ref.current.parentElement) {\n        console.log(ref.current.parentElement.getBoundingClientRect());\n        const {\n          width,\n          height,\n        } = ref.current.parentElement.getBoundingClientRect();\n        setSize(tuple(width, height));\n      }\n    }, 1);\n  }, [ref, setSize]);\n  \n  return tuple(<canvas height={height} width={width} ref={ref}></canvas>, ref)\n}\n\nfunction App() {\n  const [canvas, ref] = useCanvas()\n  Circles.useCircles(ref)\n\n  return (\n    <div id=\"app\">\n      <section>\n        {canvas}\n      </section>\n      <footer>\n        <ul>\n          <li>\n            Press <strong>1</strong> to enter \"circles\" mode. Once in this mode you can click anywhere to draw a random circle.\n            <ul>\n              <li>\n                Press <strong>S</strong> or <strong>X</strong> to cancel. You will be taken back to main mode.\n              </li>\n            </ul>\n          </li>\n          <li>\n            Press <strong>2</strong> to enter \"markers\" mode. Once in this mode you can click anywhere to draw a yellow marker.\n            <ul>\n              <li>\n                Press <strong>S</strong> or <strong>X</strong> to cancel. You will be taken back to main mode.\n              </li>\n            </ul>\n          </li>\n          <li>\n            Press <strong>X</strong> while in <i>main</i> mode to clear the canvas.\n          </li>\n        </ul>\n        <p>\n          Circles have a random radius, start angle, end angle, color and border color.\n        </p>\n      </footer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}