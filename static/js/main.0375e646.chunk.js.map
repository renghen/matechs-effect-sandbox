{"version":3,"sources":["utils/tuple.ts","utils/getter.ts","utils/effect.ts","modules/canvas/index.ts","modules/emitter/index.ts","apps/circles/index.ts","App.tsx","serviceWorker.ts","index.tsx"],"names":["tuple","ts","getter","key","o","getter2","k1","k2","dot","fromIO","io","T","sync","rndColor","alpha","Do","effect","bind","Rnd","pure","pipe","IO","a","return","r","g","b","until","uri","circle","x","y","sa","ea","accessM","_","ctx","zip","Math","PI","chain","do","strokeStyle","fillStyle","lineWidth","beginPath","arc","stroke","fill","constant","clear","clearRect","accessCanvas","canvas","canvasPropIfNot","prop","value","map","el","accessCanvasProp","canvasWidthIfNot","canvasHeightIfNot","makeClearRectLive","width","height","doL","constVoid","subscribe","type","S","fromSource","M","managed","bracket","su","queueUtils","next","ops","hasCB","unsubscribe","addEventListener","fromEvent","fn","_tag","emitter","waitForKeyPress","keyCode","filter","event","takeWhile","drain","drawCirclesOnClick","Canvas","encaseEffect","canvasEl","Emitter","s","stream","wrappedUntil","as","wrappedStream","mergeAll","wrapped","takeUntil_","e","offsetX","offsetY","D","date","collectArray","output","log","redrawCircles","circles","timestampedCircles","redraw","reduce","acc","index","prev","ms","push","delay","never","forever","race","drawAndRedraw","flow","done","main","fork","fiber","interrupt","useCircles","canvasRef","React","current","getContext","provideS","rootEl","document","cb","removeEventListener","radius","startAngle","endAngle","anticlockwise","abs","color","provideConsole","run","useCanvas","ref","useRef","useState","setSize","useEffect","setTimeout","parentElement","console","getBoundingClientRect","App","Circles","id","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.0375e646.chunk.js","sourcesContent":["export const tuple = <T extends any[]>(...ts: T) => ts;","/**\r\n * @packageDocumentation\r\n * @module utils\r\n */\r\n\r\n/**\r\n * Type that describes a function that returns\r\n * the value of on object's property given\r\n *\r\n * @typeparam TKey The key or property name the function should read and return from a given object.\r\n * @typeparam TValue The value type\r\n * @typeparam TObject The object type\r\n */\r\nexport type Getter<TKey extends string> = <\r\n  TValue,\r\n  TObject extends {\r\n    [P in TKey]: TValue;\r\n  }\r\n>(\r\n  o: TObject\r\n) => TObject[TKey];\r\n\r\n/**\r\n *\r\n * @param key\r\n */\r\nexport const getter = <K extends string>(key: K): Getter<K> => <\r\n  T,\r\n  O extends { [P in K]: T }\r\n>(\r\n  o: O\r\n) => o[key];\r\n\r\nexport const getter2 = <K1 extends string, K2 extends string>(\r\n  k1: K1,\r\n  k2: K2\r\n) => <T, O extends { [P in K1]: { [R in K2]: T } }>(o: O) => o[k1][k2];\r\n\r\nexport const dot = getter;\r\nexport const dot2 = getter2;\r\nexport const pluck = getter;\r\nexport const pluck2 = getter2;\r\n\r\nexport const getEventCurrentTargetValue = dot2(\"detail\", \"value\");\r\n","import * as IO from \"fp-ts/lib/IO\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { effect as T, stream as S } from \"@matechs/effect\";\r\n\r\nexport const fromIO = <T>(io: IO.IO<T>) => {\r\n  return T.sync(() => io());\r\n};\r\n\r\nexport const rndColor = (alpha?: number) =>\r\n  Do(T.effect)\r\n    .bind(\"r\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\"g\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\"b\", fromIO(Rnd.randomInt(0, 255)))\r\n    .bind(\r\n      \"a\",\r\n      alpha != null\r\n        ? T.pure(alpha)\r\n        : fromIO(\r\n            pipe(\r\n              Rnd.randomInt(0, 10),\r\n              IO.map((a) => a / 10)\r\n            )\r\n          )\r\n    )\r\n    .return(({ r, g, b, a }) => `rgba(${r}, ${g}, ${b}, ${a})`);\r\n\r\n/**\r\n * Take elements from a stream until a given effect resolves.\r\n *\r\n * @param until The effect that will terminate the stream\r\n * @param stream The stream\r\n */\r\nfunction takeUntil_<R1, E1, R2, E2, A>(\r\n  stream: S.Stream<R1, E1, A>,\r\n  until: T.Effect<R2, E2, any>\r\n) {\r\n  type Wrapped = { type: \"until\" } | { type: \"stream\"; value: A };\r\n\r\n  const wrappedUntil = S.as<Wrapped>({ type: \"until\" })(S.encaseEffect(until));\r\n\r\n  const wrappedStream = pipe(\r\n    stream,\r\n    S.map((value): Wrapped => ({ type: \"stream\", value }))\r\n  );\r\n\r\n  return pipe(\r\n    S.mergeAll([wrappedUntil as any, wrappedStream as any] as S.Stream<\r\n      R1 & R2,\r\n      E1 | E2,\r\n      Wrapped\r\n    >[]),\r\n    S.takeWhile((wrapped) => wrapped.type === \"stream\"),\r\n    S.filter(\r\n      (wrapped): wrapped is Extract<Wrapped, { type: \"stream\" }> =>\r\n        wrapped.type === \"stream\"\r\n    ),\r\n    S.map((wrapped) => (wrapped as Extract<Wrapped, { type: \"stream\" }>).value)\r\n  );\r\n}\r\n\r\nexport function takeUntil<R2, E2>(until: T.Effect<R2, E2, any>) {\r\n  return function <R1, E1, A>(s: S.Stream<R1, E1, A>) {\r\n    return takeUntil_(s, until);\r\n  };\r\n}\r\n","import { effect as T } from \"@matechs/effect\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constVoid, constant } from \"fp-ts/lib/function\";\r\nimport * as Rnd from 'fp-ts/lib/Random'\r\n\r\nimport { fromIO, rndColor } from '../../utils/effect'\r\nimport { tuple } from \"../../utils/tuple\";\r\n\r\nexport const uri = \"@uri/canvas\";\r\n\r\ninterface Flavoring<FlavorT> {\r\n  _type?: FlavorT;\r\n}\r\n\r\nexport type Flavor<T, FlavorT> = T & Flavoring<FlavorT>;\r\n\r\ntype Radian = Flavor<number, \"radius\">;\r\n\r\nexport interface Canvas {\r\n  [uri]: {\r\n    canvas: T.UIO<HTMLCanvasElement>;\r\n    clearRect: (\r\n      x: number,\r\n      y: number,\r\n      width?: number,\r\n      height?: number\r\n    ) => T.RUIO<Canvas, void>;\r\n    arc: (\r\n      x: number,\r\n      y: number,\r\n      radius: number,\r\n      startAngle: Radian,\r\n      endAngle: Radian,\r\n      anticlockwise?: boolean | undefined\r\n    ) => T.UIO<void>;\r\n    lineWidth: (width: number) => T.UIO<void>;\r\n    beginPath: T.UIO<void>;\r\n    stroke: T.UIO<void>;\r\n    fill: T.UIO<void>;\r\n    strokeStyle: (color: string) => T.UIO<void>;\r\n    fillStyle: (color: string) => T.UIO<void>;\r\n  };\r\n}\r\n\r\n/**\r\n * circle :: number -> number -> number -> number? -> number? -> Effect Canvas never (number, number, number)\r\n *\r\n * Draws a circle on the canvas. X, y, and radius are returned again.\r\n */\r\nexport const circle = (x: number, y: number, r: number, sa?: number, ea?: number) =>\r\n  T.accessM((_: Canvas) => {\r\n    const ctx = _[uri];\r\n    return pipe(\r\n      T.zip(\r\n        sa ? T.pure(sa) : fromIO(Rnd.randomInt(0, 360)),\r\n        ea\r\n          ? T.pure(ea)\r\n          : fromIO(Rnd.randomInt((Math.PI / 10) * 1000, Math.PI * 1000))\r\n      ),\r\n      T.chain(\r\n        ([sa, ea]) =>\r\n          Do(T.effect)\r\n            .do(\r\n              pipe(rndColor(1), T.chain(ctx.strokeStyle))\r\n            )\r\n            .do(\r\n              pipe(rndColor(), T.chain(ctx.fillStyle))\r\n            )\r\n            .do(ctx.lineWidth(2))\r\n            .do(ctx.beginPath)\r\n            .do(ctx.arc(x, y, r, sa, ea / 1000))\r\n            .do(ctx.stroke)\r\n            .do(ctx.fill)\r\n            .return(constant(tuple(x, y, r, sa, ea)))\r\n       \r\n      )\r\n    );\r\n  });\r\n\r\n/**\r\n * clear :: T.Effect Canvas never void\r\n *\r\n * Clears a canvas\r\n */\r\nexport const clear = T.accessM((_: Canvas) => _[uri].clearRect(0, 0))\r\n\r\nconst accessCanvas = T.accessM((_: Canvas) => _[uri].canvas)\r\n\r\nconst accessCanvasProp = <TProp extends keyof HTMLCanvasElement>(prop: TProp) => pipe(\r\n    accessCanvas,\r\n    T.map((el) => el[prop])\r\n)\r\n\r\nconst canvasPropIfNot = <TProp extends keyof HTMLCanvasElement>(prop: TProp) => (value?: HTMLCanvasElement[TProp]) =>  value != null\r\n? T.pure(value)\r\n: accessCanvasProp(prop)\r\n\r\nconst canvasWidthIfNot = canvasPropIfNot('width')\r\nconst canvasHeightIfNot = canvasPropIfNot('height')\r\n\r\nconst makeClearRectLive = (ctx: CanvasRenderingContext2D) => (\r\n  x: number,\r\n  y: number,\r\n  width?: number,\r\n  height?: number\r\n) =>\r\n  Do(T.effect)\r\n    .bind(\r\n      \"width\",\r\n      canvasWidthIfNot(width)\r\n    )\r\n    .bind(\r\n      \"height\",\r\n      canvasHeightIfNot(height)\r\n    )\r\n    .doL(({ width, height }) =>\r\n      T.sync(() => ctx.clearRect(x, y, width, height))\r\n    )\r\n    .return(constVoid);\r\n    \r\n\r\nexport const makeCanvasLive = (ctx: CanvasRenderingContext2D): Canvas => {\r\n  return {\r\n    [uri]: {\r\n    canvas: T.pure(ctx.canvas),\r\n      arc: (\r\n        x: number,\r\n        y: number,\r\n        radius: number,\r\n        startAngle: Radian,\r\n        endAngle: Radian,\r\n        anticlockwise = false\r\n      ) =>\r\n        T.sync(() =>\r\n          ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)\r\n        ),\r\n      clearRect: makeClearRectLive(ctx),\r\n      beginPath: T.sync(() => ctx.beginPath()),\r\n      stroke: T.sync(() => ctx.stroke()),\r\n      fill: T.sync(() => ctx.fill()),\r\n      lineWidth: (width: number) =>\r\n        T.sync(() => {\r\n          ctx.lineWidth = Math.abs(width);\r\n        }),\r\n        strokeStyle: (color: string) => T.sync(\r\n            () => { ctx.strokeStyle = color; }\r\n        ),\r\n        fillStyle: (color: string) => T.sync(\r\n            () => { ctx.fillStyle = color; }\r\n        )\r\n    },\r\n  };\r\n};\r\n","import { effect as T, stream as S, managed as M } from \"@matechs/effect\";\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constant } from \"fp-ts/lib/function\";\r\nimport { dot } from \"../../utils/getter\";\r\n\r\nexport const uri = \"@uri/emitter\";\r\n\r\ntype EventFor<TEventType extends string> = TEventType extends\r\n  | \"keypress\"\r\n  | \"keyup\"\r\n  | \"keydown\"\r\n  ? KeyboardEvent\r\n  : TEventType extends \"click\" | \"dblclick\"\r\n  ? MouseEvent\r\n  : Event;\r\n\r\ntype EventHandler<TEventType extends string> = (\r\n  evt: EventFor<TEventType>\r\n) => void;\r\n\r\nexport interface Emitter {\r\n  [uri]: {\r\n    fromEvent: <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<T.NoEnv, never, void>;\r\n    addEventListener: <THTMLElement extends HTMLElement>(\r\n      el: THTMLElement\r\n    ) => <TEventType extends string>(\r\n      type: TEventType\r\n    ) => (cb: EventHandler<TEventType>) => T.Effect<T.NoEnv, never, void>;\r\n  };\r\n}\r\n\r\n// Events\r\nexport const subscribe = <\r\n  TEventType extends string,\r\n  THTMLElement extends HTMLElement\r\n>(\r\n  type: TEventType,\r\n  el?: THTMLElement\r\n) => {\r\n  return S.fromSource(\r\n    M.managed.chain(\r\n      M.bracket(\r\n        T.accessM((_: Emitter) =>\r\n          T.sync(() => {\r\n            const { next, ops, hasCB } = S.su.queueUtils<\r\n              never,\r\n              EventFor<TEventType>\r\n            >();\r\n\r\n            const fn = el ? _[uri].addEventListener(el) : _[uri].fromEvent;\r\n\r\n            return {\r\n              unsubscribe: fn(type)((a) => next({ _tag: \"offer\", a })),\r\n              ops,\r\n              hasCB,\r\n            };\r\n          })\r\n        ),\r\n        dot(\"unsubscribe\")\r\n      ),\r\n      ({ ops, hasCB }) => S.su.emitter(ops, hasCB)\r\n    )\r\n  );\r\n};\r\n\r\nexport const makeEmitterLive = <\r\n  TRoot extends Pick<HTMLElement, \"addEventListener\" | \"removeEventListener\">\r\n>(\r\n  rootEl: TRoot\r\n): Emitter => {\r\n  return {\r\n    [uri]: {\r\n      fromEvent: <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        rootEl.addEventListener(type, cb as any);\r\n\r\n        return T.sync(() => rootEl.removeEventListener(type, cb as any));\r\n      },\r\n      addEventListener: <THTMLElement extends HTMLElement>(\r\n        el: THTMLElement\r\n      ) => <TEventType extends string>(type: TEventType) => (\r\n        cb: EventHandler<TEventType>\r\n      ) => {\r\n        el.addEventListener(type, cb as any);\r\n\r\n        return T.sync(() => el.removeEventListener(type, cb as any));\r\n      },\r\n    },\r\n  };\r\n};\r\n\r\n/**\r\n * waitForKeyPress :: number -> Effect NoEnv never void\r\n *\r\n * Given a keyCode returns an effect that resolves once the user\r\n * presses a key on the keyboard matching the key code.\r\n */\r\nexport const waitForKeyPress = (keyCode: number) =>\r\n  pipe(\r\n    subscribe(\"keyup\"),\r\n    S.filter((event) => event.keyCode === keyCode),\r\n    S.takeWhile(constant(false)),\r\n    S.drain\r\n  );\r\n","import * as React from \"react\";\r\n\r\nimport { effect as T, stream as S } from \"@matechs/effect\";\r\nimport { log, Console, provideConsole } from \"@matechs/console\";\r\nimport * as Rnd from \"fp-ts/lib/Random\";\r\nimport * as D from \"fp-ts/lib/Date\";\r\nimport * as IO from \"fp-ts/lib/IO\";\r\n\r\nimport { pipe } from \"fp-ts/lib/pipeable\";\r\nimport { constVoid, flow } from \"fp-ts/lib/function\";\r\nimport { Do } from \"fp-ts-contrib/lib/Do\";\r\nimport { dot } from \"../../utils/getter\";\r\n\r\nimport * as Canvas from \"../../modules/canvas\";\r\nimport * as Emitter from \"../../modules/emitter\";\r\nimport { fromIO, takeUntil } from \"../../utils/effect\";\r\nimport { tuple } from \"../../utils/tuple\";\r\n\r\n/**\r\n * Type alias for IO\r\n */\r\ntype IO<A> = IO.IO<A>;\r\n\r\ntype X = number;\r\ntype Y = number;\r\ntype Radius = number;\r\ntype Angle = number;\r\ntype StartAngle = Angle;\r\ntype EndAngle = Angle;\r\ntype TimeStamp = number;\r\n\r\ntype Circle = [X, Y, Radius, StartAngle, EndAngle];\r\ntype TimeStamped = [X, Y, Radius, StartAngle, EndAngle, TimeStamp];\r\n\r\n/**\r\n * ```hs\r\n * drawCircle :: (number, number) -> Stream Canvas never Circle\r\n * ```\r\n *\r\n * Draws a circle with a random radius\r\n */\r\nconst drawCircle = ([x, y]: [number, number]) =>\r\n  pipe(\r\n    // Get a random radius for the circle to draw\r\n    Rnd.randomInt(30, 200),\r\n    // Convert IO to Effect\r\n    fromIO,\r\n    // Map effect that produces a random int to an effect that draws a circle\r\n    T.chain((r) => Canvas.circle(x, y, r)),\r\n    // Turn the effect into a stream\r\n    S.encaseEffect\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * circleToTimeStamped :: Circle -> Stream NoEnv never TimeStamped\r\n * ```\r\n *\r\n * Draws a circle with a random radius\r\n */\r\nconst circleToTimeStamped = ([x, y, r, sa, ea]: Circle) =>\r\n  S.encaseEffect(\r\n    fromIO(\r\n      pipe(\r\n        // Get a timestamp using fp-ts' Date library\r\n        D.now, // IO<number>\r\n        // Map it to a tuple of x, y, radius, and date\r\n        IO.map((date) => tuple(x, y, r, sa, ea, date))\r\n      )\r\n    )\r\n  );\r\n\r\n/**\r\n * ```hs\r\n * mapMouseEventToCoords :: MouseEvent -> (X, Y\r\n * ```\r\n */\r\nconst mapMouseEventToCoords = (e: MouseEvent) => tuple(e.offsetX, e.offsetY);\r\n\r\n/**\r\n * ```hs\r\n * drawCirclesOnClick :: Effect (Console & Canvas & Emitter) never [TimeStamped]\r\n * ```\r\n *\r\n * Draw a circle on every mouseclick until the program is terminated by pressing 'd' or 'D'\r\n */\r\nconst drawCirclesOnClick = pipe(\r\n  // Read canvas element from environment\r\n  T.accessM((_: Canvas.Canvas) => _[Canvas.uri].canvas),\r\n  // Turn it into a stream\r\n  S.encaseEffect,\r\n  // Flat map the 1 element stream containing the canvas element to a stream of mouse clicks\r\n  S.chain((canvasEl) =>\r\n    // encaseObservable(fromEvent<MouseEvent>(canvasEl, \"click\"), constVoid)\r\n    Emitter.subscribe(\"click\", canvasEl)\r\n  ),\r\n  // Take mouse clicks until the user presses d or D\r\n  takeUntil(Emitter.waitForKeyPress(68)),\r\n  // Map the mouse event to it's coordinates\r\n  S.map(mapMouseEventToCoords),\r\n  // Flat map the stream of coordinates to\r\n  // a stream that draws a circle\r\n  S.chain(drawCircle),\r\n  // Turn the stream producing x, y, and radius into\r\n  // a stream producing x, y, radius, and the timestamp the circle was drawn\r\n  S.chain(circleToTimeStamped),\r\n  // Turn stream into an effect of an array of values\r\n  S.collectArray,\r\n  T.chain((output) => T.as(log(\"Done drawing!\"), output))\r\n);\r\n\r\n/**\r\n * ```hs\r\n * circles2effects :: [TimeStamped] -> Effect Canvas never any\r\n * ```\r\n *\r\n * Fold a list of timestamped circles into a single effect that draws them to canvas.\r\n *\r\n */\r\nconst circles2effects = (timestampedCircles: TimeStamped[]) =>\r\n  timestampedCircles\r\n    .reduce((acc, next, index) => {\r\n      // DeterminE the number of milliseconds the program should\r\n      // delay drawing the next circle based on the previous\r\n      // circle's timestamp.\r\n      const prev = timestampedCircles[index - 1];\r\n      const ms = prev ? (next[5] - prev[5]) / 2 : 0;\r\n\r\n      // Create an effect that redraws the circle after a delay\r\n      acc.push(\r\n        T.delay(Canvas.circle(next[0], next[1], next[2], next[3], next[4]), ms)\r\n      );\r\n      return acc;\r\n    }, [] as Array<ReturnType<typeof Canvas.circle>>)\r\n    // Turn the list of effects into a single chained effect (andThen)\r\n    .reduce((a, b) =>\r\n      pipe(\r\n        a,\r\n        T.chain(() => b)\r\n      )\r\n    );\r\n\r\n/**\r\n * ```hs\r\n * redrawCircles :: [TimeStamped] -> Effect (Emitter & Console & Canvas) never void\r\n * ```\r\n */\r\nconst redrawCircles = (circles: TimeStamped[]) => {\r\n  const redraw = Do(T.effect)\r\n    // Wait for the user to press r or R (replay)\r\n    // .do(Emitter.waitForKeyPress(82))\r\n    .do(log(\"Replaying...\"))\r\n    // Clear the canvas\r\n    .do(Canvas.clear)\r\n    .do(\r\n      // Flat map the list of circle coordinates and dates to\r\n      // a program that redraws the circles in the same amount of time\r\n      circles2effects(circles)\r\n    )\r\n    .do(T.never)\r\n    .return(constVoid);\r\n\r\n    return T.zip(\r\n        Emitter.waitForKeyPress(82),\r\n        T.forever(T.race(Emitter.waitForKeyPress(82), redraw))\r\n    )\r\n    \r\n};\r\n\r\nconst drawAndRedraw = Do(T.effect)\r\n  // Let the user draw circles until they press d or D\r\n  .bind(\"circles\", drawCirclesOnClick)\r\n  .doL(\r\n    flow(dot(\"circles\"), (circles) =>\r\n      redrawCircles(circles)\r\n    )\r\n  )\r\n  .done();\r\n\r\nexport const main: T.Effect<\r\n  Canvas.Canvas & Console & Emitter.Emitter,\r\n  never,\r\n  void\r\n> = Do(T.effect)\r\n  // Spawn a program that allows the user to draw circles and replay their drawing\r\n  .bind(\"fiber\", T.fork(drawAndRedraw))\r\n  // Wait for the user to press x or X to cancel\r\n  .do(Emitter.waitForKeyPress(88))\r\n  // Interrupt the fiber\r\n  .doL(({ fiber }) => fiber.interrupt)\r\n  // Clear the canvas\r\n  .do(Canvas.clear)\r\n  // Reboot\r\n  .doL(() => main)\r\n  .return(constVoid);\r\n\r\nexport const useCircles = (\r\n  canvasRef: React.MutableRefObject<HTMLCanvasElement | null>\r\n) =>\r\n  React.useEffect(() => {\r\n    if (canvasRef.current) {\r\n      const ctx = canvasRef.current.getContext(\"2d\");\r\n\r\n      if (ctx) {\r\n        pipe(\r\n          main,\r\n          T.provideS(Emitter.makeEmitterLive(document)),\r\n          T.provideS(Canvas.makeCanvasLive(ctx)),\r\n          provideConsole,\r\n          T.run\r\n        );\r\n      }\r\n    }\r\n  }, [canvasRef]);\r\n","import \"./App.scss\";\n\nimport React from \"react\";\nimport { tuple } from \"./utils/tuple\";\nimport * as Circles from './apps/circles'\n\n// Hooks\nconst useCanvasRef = () => React.useRef<HTMLCanvasElement | null>(null);\nconst useSizeState = () => React.useState(tuple(0, 0));\n\nconst useCanvas = () => {\n  const ref = useCanvasRef()\n  const [[width, height], setSize] = useSizeState()\n\n  React.useEffect(() => {\n    setTimeout(() => {\n      if (ref.current && ref.current.parentElement) {\n        console.log(ref.current.parentElement.getBoundingClientRect());\n        const {\n          width,\n          height,\n        } = ref.current.parentElement.getBoundingClientRect();\n        setSize(tuple(width, height));\n      }\n    }, 1);\n  }, [ref, setSize]);\n  \n  return tuple(<canvas height={height} width={width} ref={ref}></canvas>, ref)\n}\n\nfunction App() {\n  const [canvas, ref] = useCanvas()\n  Circles.useCircles(ref)\n\n  return (\n    <div id=\"app\">\n      <section>\n        {canvas}\n      </section>\n      <footer>\n        <ul>\n          <li>\n            Click anywhere on the canvas to draw a circle with a random.\n          </li>\n          <li>\n            Press <i>x</i> to reset.\n          </li>\n          <li>\n            Press <i>d</i> to commit.\n          </li>\n          <li>\n            Press <i>r</i> to replay <i>(after commiting.)</i>.\n          </li>\n          <li>\n            Press <i>r</i> again while replaying to cancel and restart.\n          </li>\n        </ul>\n        <p>\n          You can redraw as many times as you want once a drawing has been comitted. Size and\n          coordinates are preserved. Colours are not. Redrawing happens at twice.          \n        </p>\n        <p>\n          Circles have a random radius, start angle, end angle, color and border color.\n        </p>\n      </footer>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.scss\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}